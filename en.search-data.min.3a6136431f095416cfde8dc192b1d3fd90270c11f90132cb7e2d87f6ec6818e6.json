[{"id":0,"href":"/showcase/docs/Members/","title":"Members","section":"Docs","content":"Miembros #  En esta sección se presentarán los integrantes para la presentación de los trabajos de Computación Visual. Conformados por:\n Andrés Felipe Betancurth Becerra Juan Manuel Correa Lombana Gabriela María García Romero  "},{"id":1,"href":"/showcase/docs/Members/Andr%C3%A9s-Felipe-Betancurth-Becerra/","title":"Andrés Felipe Betancurth Becerra","section":"Members","content":"Andrés Felipe Betancurth Becerra #  estudiante de decima matricula de Ingeniería de Sistemas y Computación en la Universidad Nacional de Colombia con lo que es practicamente solo la mitad de avance de mi carrera, me interesa el campo de la inteligencia artificial orientado al maching lerning, las curiosidades y las series.\n"},{"id":2,"href":"/showcase/docs/Members/Gabriela-Mar%C3%ADa-Garc%C3%ADa-Romero/","title":"Gabriela María García Romero","section":"Members","content":"Gabriela María García Romero #  Estudiante de octavo semestre de Ingeniería de Sistemas y Computación en la Universidad Nacional de Colombia. Con interés en temas de modelización e inteligencia artificial. Actualmente se desempeña como representante estudiantil ante el Comité Asesor de la carrea.\nHace parte de los siguientes grupos:\n Semillero Laboratorio de Investigación en Sistemas Inteligentes (LISI) WIE (Women in Engineering)  "},{"id":3,"href":"/showcase/docs/Members/Juan-Manuel-Correa-Lombana/","title":"Juan Manuel Correa Lombana","section":"Members","content":"Juan Manuel Correa Lombana #  Estudiante de octavo semestre de Ingeniería de Sistemas y Computación en la Universidad Nacional de Colombia. , con 1 año de experiencia en manejo de datos y ciencia de datos. Entre sus proyectos realizados se encuentra:\n 6 meses en un proyecto de grafos y optimización de rutas de transporte usando inteligencia artificial 8 meses como analista de datos y ciencia de datos Actualmente llevo 2 meses en ingeniería de datos en el área de arquitectura de bases de datos  "},{"id":4,"href":"/showcase/docs/Perlin-Noise/","title":"Perlin Noise","section":"Docs","content":"Ruido de Perlin #  El ruido de perlin es una función utilizada en la computación gráfica para crear texturas primitivas. Este fue desarrollado por Ken Perlin en 1983, cuando publicó un artículo llamado An Image Synthesizer.\n¿Qué es ruido? #  El ruido es una función pseudo-aleatoria a partir de la cual se pueden generar texturas. Esta se puede representar como una rejilla como la mostrada a continuación:\nEn donde cada vertice tiene asociado un vector\n un vector es un segmento de recta con magnitud y dirección           \"  Este es un vector gradiente pseudo aleatorio.\nAsí, el valor del ruido Perlin en el punto se calcula como un producto punto entre el punto entre los vectores de gradiente en los vértices de la grilla y los vectores desde el punto dado a estos vértices.\nPara finalizar, de interpola el resultado con una función. Generalmente se utiliza este polinomio cúbico:\n3x^2 -2x^3  Características #  Entre sus características están:\n Pseudo-aleatoria Invariante estadísticamente bajo la rotación y translación Tiene un filtro pasa bandas en su frecuencia  Esto permite crear superficies a diferentes escalas, y sin perder el control del efecto al rotar y trasladar.\nNaturalidad #  El objetivo de Perlin con el diseño del algoritmo era la generación de gráficos que fueran más naturales, es decir, que emulen movimientos y texturas de la naruraleza, obteniendo texturas \u0026ldquo;realistas\u0026rdquo;. Esto lo hace al crear secuencias naturalmente ordenadas y suaves de números pseudoaleatorios.\nEs por esta razón que el ruido de Perlin se ha utilizado para crear representaciones convincentes de nubes, fuego, agua, estrellas, tierra, entre otros.\nReferencias #  Michot-Roberto, S., Garcia-Hernández, A., Dopazo-Hilario, S., \u0026amp; Dawson, A. (2021). The spherical primitive and perlin noise method to recreate realistic aggregate shapes. Granular Matter, 23(2), 1-11.\nPerlin, K. (1985). An image synthesizer. ACM Siggraph Computer Graphics, 19(3), 287-296.\nTatarinov, A. (2008). Perlin noise in real-time computer graphics. In GraphiCon (pp. 177-183).\nEn.wikipedia.org. 2022. Perlin noise - Wikipedia. [online] Available at: https://en.wikipedia.org/wiki/Perlin_noise [Accessed 5 April 2022].\n"},{"id":5,"href":"/showcase/docs/Perlin-Noise/Particule/","title":"Particule","section":"Perlin Noise","content":"Movimiento de partículas a través de un campo de perlin noise #  En el siguiente frame se puede ver el movimiento con rastro de partículas a través de un campo de perlin noise\n          \"           \"           \"  si jugamos con la rejilla y la dirección de los vectores, se pueden generar texturas o efectos visuales más complejos\nSnow #           \"  Grass #           \"  Según lo explica Andre Tatarinov en su paper titulado Perlin noise in Real-time Computer Graphics, esto también se puede usar para generar efectos dinámicos volumétricos como fuego, una explosión o humo, esto solo cambiando la dirección y el comportamiento de los vectores asociados a la rejilla.\n"},{"id":6,"href":"/showcase/docs/Perlin-Noise/Terrain/","title":"Terrain","section":"Perlin Noise","content":"Terreno procedural #  {{\u0026lt; let terrain = []; function setup() {  createCanvas(500, 500, WEBGL);  cols = 0;rows = 0;  elevacion = 100;  scl = 25;  vel = 0.05;  cambio = scl;  crecimiento = 0.07;  w = 800;  h = 800;  cols = w/scl;  rows = h/scl;  avance = 0;  }   function stripOfTerrain(){  yoff = avance;  xoff = 0;  for(x = 0; x \u0026lt; (cols);x++){  terrain[x] = [];  }  for(y = 0; y \u0026lt; (rows); y++){  xoff = 0;  for(x = 0; x \u0026lt; (cols);x++){  terrain[x][y] = map(noise(xoff,yoff),0,1,-elevacion,elevacion);  xoff += crecimiento;  }  yoff += crecimiento;  } }  function draw() {  stripOfTerrain();  cols = w/scl;  rows = h/scl;  avance -= vel;  background(\u0026#39;blue\u0026#39;);  stroke(255);  rotateX(PI/3);  translate(-375,-525);  for(y = 0; y \u0026lt; rows; y++){  beginShape(TRIANGLE_STRIP);  for(x = 0; x \u0026lt; cols;x++){  fill(10,200,200-terrain[x][y]*10)  vertex(x*scl,y*scl,terrain[x][y]);  fill(10,255,100-terrain[x][y+1]*10)  vertex(x*scl,(y+1)*scl,terrain[x][y+1]);  }  endShape();  } } \u0026gt;}} All parameters are optional but sketch. Default values are shown in the above snippet but for libs*. Up to lib5 libs may be specified.\n         \"  "},{"id":7,"href":"/showcase/docs/Renderizaci%C3%B3n/1.-Original/","title":"1. Original","section":"Renderización","content":"Proporcionalidad y simetría #  La clave en la ilusión realizada en el juego por la percepción forzada es la proporcionalidad que existe entre el campo de visión y el objeto. El objeto crece tanto como el campo de visión. Esto se puede demostrar con el teorema de proporcionalidad de los triángulos, en los que la razón entre z/z\u0026rsquo; es equivalente a la razón entre x/x\u0026rsquo;, siendo θ el ángulo del campo de visión:\nEs decir que un cambio en la ditancia en la que se aleja el objeto va a ser proporcional al tamaño el cual este crezca.\nA continuación se muestra el código en el que se explora el fenómeno de la perspectiva forzada, este tiene dos escenas, la una, es la de la cámara y, la otra, es el espacio de la pantalla. Mediante el siguiente código se puede observar cómo los cambios hechos desde la perespectiva de la cámara se ven reflejados en la el espacio de la pantalla.\n            \"  "},{"id":8,"href":"/showcase/docs/Renderizaci%C3%B3n/2.-Densidad-de-pixel/","title":"2. Densidad De Pixel","section":"Renderización","content":"El mundo y el pixel #  Cada pixel en la pantalla representa una cantidad espacio en el espacio del mundo. La ilusión de la perspectiva forzada permite guardar la relación que existe entre el mundo y el pixel, es decir, la cantidad mundo que puede ser representado en el pixel en el espacio de la pantalla, a esta relación se le va a denominar densidad y es utilizada por la función pixelRatio en el código anteriormente visto.\n         \"  Alejar los objetos #  Cuando se aleja el objeto de la pantalla sobre la cual está siendo mostrado, por el ángulo del campo de visión, el objeto reduce su tamaño en la pantalla, sin embargo, en el mundo este sigue conservado su tamaño. Eso quiere decir que cada pixel va a contener más información del mundo, a pesar de que la escena sea la misma.\n         \"  Cambio de tamaño #  ¿Que pasaría entonces si aumentamos el tamaño mientras se aleja la escena? Si sea aumenta el tamaño del objeto de la misma velocidad en la que crece el ángulo de campo de visión, lo que sucedería es que la escena generada en pantalla no cambiaría, aun cuando el tamaño del objeto si cambia.\nLo que si cambia es la densidad de los pixeles, ya que aún cuando el objeto es más grande en el mundo, en la pantalla es del mismo tamaño, es decir, que en este caso la cantidad que almacena cada pixel del mundo aumenta.\n         \"  "},{"id":9,"href":"/showcase/docs/Renderizaci%C3%B3n/","title":"Renderización","section":"Docs","content":"Introducción #  Uno de los problemas que enfrenta la computación gráfica es el de cómo se puede representar una imagen o un modelo 3D en una monitor o pantalla 2D. Este es relevante, debido a que los monitores sobre los cuales se muestran las imágenes no son espacios continuos como lo es el mundo real, en cambio, este está representado por una cuadrícula de pixeles, los cuales son una unidad discreta que solo puede tomar un valor de color.\nEl computador entonces guarda el modelo de la representación de la escena, ya sea 2D o 3D, que va a ser mostrado en la pantalla, este proceso es llamado renderización, y es un proceso llevado a cabo en la animación, videojuegos, modelizaciones 3D, entre otros.\nEn el presente artículo se va a presentar cómo el proceso de rendering, conocida como la tubería de renderizado (o por su nombre en ingles graphic pipeline) permite una perspectiva forzada de los cuales se basa el juego Superliminal.\nRenderización #  Cuando se renderiza una escena, el objetivo principal es de escoger una escena de la cual se va a renderizar (va a tener su propia posición, orientación y zoom) y una “ventana” o mejor conocida en computación gráfica como pantalla, a la cual la figura va a ser traducida.La renderización se hace por medio del cambio de distintos espacios de coordenadas. Estos espacios de cooordenadas son:\nEspacio del Modelo #  Este es el espacio de coordenadas x,y,z bajo el cual está definida la geometría del objeto, usualmente el objeto se realiza mediante el vértices y superficies normales.\nMundo #  El mundo es el espacio bajo el cual toda la escena está definida, este tiene su origen en el centro de la escena. Se puede pasar del espacio del modelo al espacio del mundo por medio de una transformación de modelos.\nCámara u ojo #  La cámara el punto de vista desde el cual se ve el mundo. Es el un espacio coordinado con origen en el centro de la proyección.\nEspacio de pantalla #  El espacio de la pantalla es una proyección de la cámara a un espacio en 2D. Este se utiliza para proyectar lo del espacio de la cámara a una representación en monitores como se conoce hoy en día en los computadores.\nTubería de renderización #  Este es un proceso que decribe los pasos de la renderización de un objeto a su forma 2D o, mejor dicho, del espacio del objeto al espacio de la pantalla.\nSuperliminal #  Superliminal es un videojuego desde la perspectiva de primera persona. La trama del juego consiste en un jugador que se encuentra atrapado en un lugar surreal llamado el espacio de sueños y este debe hallar maneras de escapar de ese lugar. Sin embargo, una características del espacio de sueños mencionados es que el jugador puede cambiar el tamaño de los objetos utilizando la perspectiva forzada.\nPerspectiva forzada #  La perspectiva forzada es un fenómeno en el que el observador es engañado acerca del tamaño de un objeto, es decir, este puede parecer más grande o más pequeño de lo que en realidad es. Esto ocurre ya que la representación de la escena en el ojo humano, en este caso la cámara, percibe el objeto de una manera que parece distinta a la realidad.\nEn el caso específico del juego, el jugador tiene el control de la perspectiva forzada, en cuanto este puede en el mundo aumentar y disminuir el tamaño de los objetos sin que, bajo la perspectiva de la cámara se cambie el tamaño.\n11\nEsto se logra porque ante el espacio de la pantalla que es generado ante el proceso de renderización, la scena creada no cambia a pesar de que en el mundo el objeto sí este cambiando.\n"},{"id":10,"href":"/showcase/docs/Renderizaci%C3%B3n/Concept-1/","title":"Concept 1","section":"Renderización","content":"concepto 1 #             \"  "},{"id":11,"href":"/showcase/docs/Renderizaci%C3%B3n/Concept-2/","title":"Concept 2","section":"Renderización","content":"concepto 2 #  "},{"id":12,"href":"/showcase/docs/Renderizaci%C3%B3n/Concept-3/","title":"Concept 3","section":"Renderización","content":"concepto 3 #  "}]