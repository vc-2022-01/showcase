[{"id":0,"href":"/showcase/docs/Members/","title":"Members","section":"Docs","content":"Miembros #  En esta sección se presentarán los integrantes para la presentación de los trabajos de Computación Visual. Conformados por:\n Andrés Felipe Betancurth Becerra Juan Manuel Correa Lombana Gabriela María García Romero  "},{"id":1,"href":"/showcase/docs/Members/Andr%C3%A9s-Felipe-Betancurth-Becerra/","title":"Andrés Felipe Betancurth Becerra","section":"Members","content":"Andrés Felipe Betancurth Becerra #  estudiante de decima matricula de Ingeniería de Sistemas y Computación en la Universidad Nacional de Colombia con lo que es practicamente solo la mitad de avance de mi carrera, me interesa el campo de la inteligencia artificial orientado al maching lerning, las curiosidades y las series.\n"},{"id":2,"href":"/showcase/docs/Members/Gabriela-Mar%C3%ADa-Garc%C3%ADa-Romero/","title":"Gabriela María García Romero","section":"Members","content":"Gabriela María García Romero #  Estudiante de octavo semestre de Ingeniería de Sistemas y Computación en la Universidad Nacional de Colombia. Con interés en temas de modelización e inteligencia artificial. Actualmente se desempeña como representante estudiantil ante el Comité Asesor de la carrea.\nHace parte de los siguientes grupos:\n Semillero Laboratorio de Investigación en Sistemas Inteligentes (LISI) WIE (Women in Engineering)  "},{"id":3,"href":"/showcase/docs/Members/Juan-Manuel-Correa-Lombana/","title":"Juan Manuel Correa Lombana","section":"Members","content":"Juan Manuel Correa Lombana #  Estudiante de octavo semestre de Ingeniería de Sistemas y Computación en la Universidad Nacional de Colombia. , con 1 año de experiencia en manejo de datos y ciencia de datos. Entre sus proyectos realizados se encuentra:\n 6 meses en un proyecto de grafos y optimización de rutas de transporte usando inteligencia artificial 8 meses como analista de datos y ciencia de datos Actualmente llevo 2 meses en ingeniería de datos en el área de arquitectura de bases de datos  "},{"id":4,"href":"/showcase/docs/Perlin-Noise/","title":"Perlin Noise","section":"Docs","content":"Ruido de Perlin #  El ruido de perlin es una función utilizada en la computación gráfica para crear texturas primitivas. Este fue desarrollado por Ken Perlin en 1983, cuando publicó un artículo llamado An Image Synthesizer.\n¿Qué es ruido? #  El ruido es una función pseudo-aleatoria a partir de la cual se pueden generar texturas. Esta se puede representar como una rejilla como la mostrada a continuación:\nEn donde cada vertice tiene asociado un vector\n un vector es un segmento de recta con magnitud y dirección           \"  Este es un vector gradiente pseudo aleatorio.\nAsí, el valor del ruido Perlin en el punto se calcula como un producto punto entre el punto entre los vectores de gradiente en los vértices de la grilla y los vectores desde el punto dado a estos vértices.\nPara finalizar, de interpola el resultado con una función. Generalmente se utiliza este polinomio cúbico:\n3x^2 -2x^3  Características #  Entre sus características están:\n Pseudo-aleatoria Invariante estadísticamente bajo la rotación y translación Tiene un filtro pasa bandas en su frecuencia  Esto permite crear superficies a diferentes escalas, y sin perder el control del efecto al rotar y trasladar.\nNaturalidad #  El objetivo de Perlin con el diseño del algoritmo era la generación de gráficos que fueran más naturales, es decir, que emulen movimientos y texturas de la naruraleza, obteniendo texturas \u0026ldquo;realistas\u0026rdquo;. Esto lo hace al crear secuencias naturalmente ordenadas y suaves de números pseudoaleatorios.\nEs por esta razón que el ruido de Perlin se ha utilizado para crear representaciones convincentes de nubes, fuego, agua, estrellas, tierra, entre otros.\nReferencias #  Michot-Roberto, S., Garcia-Hernández, A., Dopazo-Hilario, S., \u0026amp; Dawson, A. (2021). The spherical primitive and perlin noise method to recreate realistic aggregate shapes. Granular Matter, 23(2), 1-11.\nPerlin, K. (1985). An image synthesizer. ACM Siggraph Computer Graphics, 19(3), 287-296.\nTatarinov, A. (2008). Perlin noise in real-time computer graphics. In GraphiCon (pp. 177-183).\nEn.wikipedia.org. 2022. Perlin noise - Wikipedia. [online] Available at: https://en.wikipedia.org/wiki/Perlin_noise [Accessed 5 April 2022].\n"},{"id":5,"href":"/showcase/docs/Perlin-Noise/Particule/","title":"Particule","section":"Perlin Noise","content":"Movimiento de partículas a través de un campo de perlin noise #  En el siguiente frame se puede ver el movimiento con rastro de partículas a través de un campo de perlin noise\n          \"           \"           \"  si jugamos con la rejilla y la dirección de los vectores, se pueden generar texturas o efectos visuales más complejos\nSnow #           \"  Grass #           \"  Según lo explica Andre Tatarinov en su paper titulado Perlin noise in Real-time Computer Graphics, esto también se puede usar para generar efectos dinámicos volumétricos como fuego, una explosión o humo, esto solo cambiando la dirección y el comportamiento de los vectores asociados a la rejilla.\n"},{"id":6,"href":"/showcase/docs/Perlin-Noise/Terrain/","title":"Terrain","section":"Perlin Noise","content":"Terreno procedural #  {{\u0026lt; let terrain = []; function setup() {  createCanvas(500, 500, WEBGL);  cols = 0;rows = 0;  elevacion = 100;  scl = 25;  vel = 0.05;  cambio = scl;  crecimiento = 0.07;  w = 800;  h = 800;  cols = w/scl;  rows = h/scl;  avance = 0;  }   function stripOfTerrain(){  yoff = avance;  xoff = 0;  for(x = 0; x \u0026lt; (cols);x++){  terrain[x] = [];  }  for(y = 0; y \u0026lt; (rows); y++){  xoff = 0;  for(x = 0; x \u0026lt; (cols);x++){  terrain[x][y] = map(noise(xoff,yoff),0,1,-elevacion,elevacion);  xoff += crecimiento;  }  yoff += crecimiento;  } }  function draw() {  stripOfTerrain();  cols = w/scl;  rows = h/scl;  avance -= vel;  background(\u0026#39;blue\u0026#39;);  stroke(255);  rotateX(PI/3);  translate(-375,-525);  for(y = 0; y \u0026lt; rows; y++){  beginShape(TRIANGLE_STRIP);  for(x = 0; x \u0026lt; cols;x++){  fill(10,200,200-terrain[x][y]*10)  vertex(x*scl,y*scl,terrain[x][y]);  fill(10,255,100-terrain[x][y+1]*10)  vertex(x*scl,(y+1)*scl,terrain[x][y+1]);  }  endShape();  } } \u0026gt;}} All parameters are optional but sketch. Default values are shown in the above snippet but for libs*. Up to lib5 libs may be specified.\n         \"  "},{"id":7,"href":"/showcase/docs/Renderizaci%C3%B3n/1.-Baseline/","title":"1. Baseline","section":"Renderización","content":"Proporcionalidad y simetría #  La clave en la ilusión realizada en el juego por la percepción forzada es la proporcionalidad que existe entre el campo de visión y el objeto. El objeto crece tanto como el campo de visión. Esto se puede demostrar con el teorema de proporcionalidad de los triángulos, en los que la razón entre z\u0026rsquo;/z es equivalente a la razón entre x\u0026rsquo;/x, dado que tienen el mismo θ el ángulo del campo de visión:\n   \\[ \\frac{x\u0026#39;}{x} = \\frac{z\u0026#39;}{z} \\]  entonces\n \\[ x\u0026#39; = \\frac{z\u0026#39;*x}{z} \\]  Lo mismo sucede con el eje y:\n \\[ \\frac{y\u0026#39;}{y} = \\frac{z\u0026#39;}{z} \\]  así\n \\[ y\u0026#39; = \\frac{z\u0026#39;*y}{z} \\]  Es decir que un cambio en la distancia en la que se aleja el objeto va a ser proporcional al tamaño el cual este crezca. Y la percepción que obtenga la cámara va a ser simétrica.\nCódigo base #  A continuación se muestra el código en el que se explora el fenómeno de la perspectiva forzada, este tiene dos escenas, la una, es la de la cámara y, la otra, es el espacio de la pantalla. Mediante el siguiente código se puede observar cómo los cambios hechos desde la perespectiva de la cámara se ven reflejados en la el espacio de la pantalla.\nInstrucciones #   Se selecciona una de las cajas oprimiendo uno de los números de 0 a 9, esta va a tornarse a un color rojo Se utiliza la letra w para alejar la caja y la letra z para alejar Se utiliza el dezlizador para ajustar el zoom de la cámara En la izquierda se puede ver como la caja sigue del mismo tamaño, mientras que en la derecha se puede ver como el objeto va aumentando o disminuyendo de tamaño en el mundo.              \"  Base superliminal let fbo1, fbo2; let cam1, cam2; let target = 150; let length = 600; let boxes; let box_key; let fovy; const SPEED = 5;  function setup() {  createCanvas(length, length / 2);  // frame buffer object instances (FBOs)  fbo1 = createGraphics(width / 2, height, WEBGL);  fbo2 = createGraphics(width / 2, height, WEBGL);  // FBOs cams  cam1 = new Dw.EasyCam(fbo1._renderer, { distance: 200 });  let state1 = cam1.getState();  cam1.attachMouseListeners(this._renderer);  cam1.state_reset = state1; // state to use on reset (double-click/tap)  cam1.setViewport([0, 0, width / 2, height]);  cam2 = new Dw.EasyCam(fbo2._renderer, { rotation: [0.94, 0.33, 0, 0] });  cam2.attachMouseListeners(this._renderer);  let state2 = cam2.getState();  cam2.state_reset = state2; // state to use on reset (double-click/tap)  cam2.setViewport([width / 2, 0, width / 2, height]);  document.oncontextmenu = function () { return false; }  // scene  colorMode(RGB, 1);  let trange = 100;  boxes = [];  for (let i = 0; i \u0026lt; 10; i++) {  boxes.push(  {  position: createVector((random() * 2 - 1) * trange, (random() * 2 - 1) * trange, (random() * 2 - 1) * trange),  size: random() * 25 + 8,  color: color(random(), random(), random())  }  );  }  fovy = createSlider(PI / 12, PI * (11 / 12), PI / 3, PI / 48);  fovy.position(10, 10);  fovy.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); }  function draw() {  fbo1.background(200, 125, 115);  fbo1.reset();  fbo1.perspective(fovy.value());  fbo1.axes();  fbo1.grid();  scene1();  beginHUD();  image(fbo1, 0, 0);  endHUD();  fbo2.background(130);  fbo2.reset();  fbo2.axes();  fbo2.grid();  scene2();  fbo2.viewFrustum(fbo1);  beginHUD();  image(fbo2, width / 2, 0);  endHUD(); }  function scene1() {  boxes.forEach(box =\u0026gt; {  fbo1.push();  fbo1.fill(boxes[box_key] === box ? color(\u0026#39;red\u0026#39;) : box.color);  fbo1.translate(box.position);  if (boxes[box_key] === box) {  if (keyIsPressed \u0026amp;\u0026amp; !mouseIsPressed) {  let boxLocation = fbo1.treeLocation([0, 0, 0], { from: fbo1.mMatrix(), to: \u0026#39;WORLD\u0026#39; });  let pixelRatio = fbo1.pixelRatio(boxLocation);  box.target ??= box.size / pixelRatio;  box.size = box.target * pixelRatio;  let eyeLocation = fbo1.treeLocation([0, 0, 0], { from: \u0026#39;EYE\u0026#39;, to: \u0026#39;WORLD\u0026#39; });  box.position.add(p5.Vector.sub(boxLocation, eyeLocation).normalize().mult(key === \u0026#39;w\u0026#39; ? SPEED : -SPEED));  }  else {  box.target = undefined;  }  }  fbo1.box(box.size);  fbo1.pop();  }  ); }  function scene2() {  boxes.forEach(box =\u0026gt; {  fbo2.push();  fbo2.fill(boxes[box_key] === box ? color(\u0026#39;red\u0026#39;) : box.color);  fbo2.translate(box.position);  fbo2.box(box.size);  fbo2.pop();  }  ); }  function keyPressed() {  // press [0..9] keys to pick a box and other keys  // to unpick, excepting \u0026#39;w\u0026#39; and \u0026#39;z\u0026#39; which are used  // to move the box away or closer to eye.  if (key !== \u0026#39;w\u0026#39; \u0026amp;\u0026amp; key !== \u0026#39;z\u0026#39;) {  box_key = parseInt(key);  } }    "},{"id":8,"href":"/showcase/docs/Renderizaci%C3%B3n/2.-Densidad-de-pixel/","title":"2. Densidad De Pixel","section":"Renderización","content":"El mundo y el pixel #  Cada pixel en la pantalla representa una cantidad espacio en el espacio del mundo. La ilusión de la perspectiva forzada permite guardar la relación que existe entre el mundo y el pixel, es decir, la cantidad mundo que puede ser representado en el pixel en el espacio de la pantalla, a esta relación se le va a denominar densidad y es utilizada por la función pixelRatio en el código anteriormente visto.\n         \"  Alejar los objetos #  Cuando se aleja el objeto de la pantalla sobre la cual está siendo mostrado, por el ángulo del campo de visión, el objeto reduce su tamaño en la pantalla, sin embargo, en el mundo este sigue conservado su tamaño. Eso quiere decir que cada pixel va a contener más información del mundo, a pesar de que la escena sea la misma.\n         \"  Cambio de tamaño #  ¿Que pasaría entonces si aumentamos el tamaño mientras se aleja la escena? Si se aumenta el tamaño del objeto de la misma velocidad en la que crece el ángulo de campo de visión, lo que sucedería es que la escena generada en pantalla no cambiaría, aun cuando el tamaño del objeto si cambia.\nLo que si cambia es la densidad de los pixeles, ya que aún cuando el objeto es más grande en el mundo, en la pantalla es del mismo tamaño, es decir, que en este caso la cantidad que almacena cada pixel del mundo aumenta.\n         \"  "},{"id":9,"href":"/showcase/docs/Renderizaci%C3%B3n/3.-Aplicaciones/","title":"3. Aplicaciones","section":"Renderización","content":"Concept 1 #  En el presente ejemplo se realiza una demostración intuitiva de lo que es la percepcion forzada. Se utilizan dos esferas que, a perspectiva, se ven del mismo tamaño. Sin embargo, se puede cambiar el tamaño de una de ellas de tal manera que cambia de tamaño en el mundo, pero la cámara las percive del mismo tamaño. Esto pasa por la distancia en relación con la cámara.\n           \"  Concept 2 #  En el presente ejemplo consiste en un juego para encerrar a un pájaro dentro de una jaula. Al igual que en superliminal se puede modificar el tamaño de la jaula para alcanzar el objetivo.\n           \"  Concept 3 #  La siguiente es un efecto visual conseguido al cambiar el tamñao de una esfera con respecto a el plano mostrado.\n           \"  "},{"id":10,"href":"/showcase/docs/Renderizaci%C3%B3n/4.-Conslusiones/","title":"4. Conslusiones","section":"Renderización","content":"Conclusiones #  El juego Superliminal es posible gracias a elementos de la renderización que ocurren en la computación gráfica. Es mediante el proceso de la tubería de renderización que es posible lograr el efecto de percepción forzada sobre los jugadores. A pesar de que un objeto cambie en el mundo, por su ubicación y tamaño en este mismo, este cambio no es percibible en la cámara ni proyectable en la pantalla.\nA pesar de eso, el presente trabajo no considera otros atributos de la renderización cómo las sombras y la luz, que afectan el resultado de la proyección de los objetos según su profundidad. Si este fuera el caso, las sombras y la luz de un objeto lejano será percibido de manera distinta por la cámara, aún cuando su tamaño sea el mismo en la proyección.\nEl teorema de proporcionalidad de triángulos es indispensable para el efecto de percepción forzada. Este permite calcular las nuevas coordenadas en x y y a partir del cambio que ocurre en z. Esto ocurre gracias que en el mundo el objeto debe conservar el mismo ángulo con respecto al campo visual para que su proyección en la pantalla no cambie.\nFinalmente, mediante este trabajo se puede dar a notar que los pixeles son un modelo de representación del mundo, es decir, estos contienen información sobre el mundo, como, por ejemplo, el color. Sin embargo, en ocasiones un mismo píxel contiene más información sobre el mundo, esto por la lejanía de los objetos.\nTrabajo futuro: #  Este trabajo pone un punto de partida para pensar en nuevas ilusiones visuales a partir del efecto de la percepción forzada, que engañe la percepción humana sobre lo que está viendo en realidad por medio de una pantalla. Se puede pensar en una nueva era de juegos en la que la percepción jugué un papel importante y traiga un efecto innovador, así como en otras aplicaciones de la renderización como lo son la animación y también puede ser la industria cinematográfica.\nTambién, se puede pensar en maneras más intuitivas de las acciones de cambiar el tamaño de los objetos en el mundo, haciendo que estas sean distintas de oprimir las teclas w y z, para que el jugador entienda de una mejor manera qué esta haciendo cuando cambia el tamaño de los objetos en el mundo.\nPor otro lado, es importante entender de una manera más clara los conceptos de la visión humana, para poder entender cómo atributos como la profundidad afecta la percepción forzada de los objetos.\nPara finalizar, todas estas transformaciones son hechas mientras tanto la cámara cómo el objeto están fijos. Una aplicación futura sería realizar la ilusión de percepción forzada cuando hay movimiento en alguno de estos dos espacios.\nReferencias #    https://blog.playstation.com/2020/06/30/breaking-down-the-tech-behind-superliminals-mind-bending-illusions/\n  https://findnerd.com/list/view/Computer-Graphics-Different-Spaces/6982/\n  https://tfetimes.com/wp-content/uploads/2015/04/F.Dunn-I.Parberry-3D-Math-Primer-for-Graphics-and-Game-Development.pdf\n  "},{"id":11,"href":"/showcase/docs/Renderizaci%C3%B3n/","title":"Renderización","section":"Docs","content":"Introducción #  Uno de los problemas que enfrenta la computación gráfica es el de cómo se puede representar una forma o un modelo 3D en una monitor o pantalla 2D. Este es relevante, debido a que los monitores sobre los cuales se muestran las imágenes no son espacios continuos como lo es el mundo real, en cambio, este está representado por una cuadrícula de pixeles, los cuales son una unidad discreta que solo puede tomar un valor de color.\nEl computador entonces guarda el modelo de la representación de la escena, que va a ser mostrado en la pantalla, este proceso es llamado renderización, y es un proceso llevado a cabo en la animación, videojuegos, modelizaciones 3D, entre otros.\nEn el presente trabajo se va a presentar cómo el proceso de rendering, conocida como la tubería de renderizado (o por su nombre en ingles graphic pipeline) permite una perspectiva forzada de los cuales se basa el juego Superliminal.\nRenderización #  Cuando se renderiza una escena, el objetivo principal es de escoger un modelo el cual se va a renderizar (va a tener su propia posición, orientación y zoom) y una “pantalla\u0026quot; representada en dos dimensiones, a la cual la figura va a ser traducida. La renderización se hace por medio del cambio de distintos espacios de coordenadas. Estos espacios de cooordenadas son:\nEspacio del Modelo #  Este es el espacio de coordenadas x,y,z bajo el cual está definida la geometría del objeto, usualmente el objeto se define mediante primitivas en este espacio.\nMundo #  El mundo es el espacio bajo el cual toda la escena está definida, este tiene su origen en el centro de la escena. Se puede pasar del espacio del modelo al espacio del mundo por medio de una transformación de modelos.\nCámara u ojo #  Es el espacio coordinado con origen en el centro de la proyección. La cámara es el punto de vista desde el cual se ve el mundo, este forma un campo de visión formado a partir de cuatro rayos.\nZoom #  Unas de las características del espacio de cámara es el zoom. Este se origina dado que el campo de visión, forma ángulos con los ejes coordinados x y y. Entre más grande sean estos ángulos, de más espacio del mundo se tendrá una proyección y viceversa.\nEl zoom le permitiría a la cámara aumentar el espacio que percibe por medio del aumento de sus ángulos, siempre y cuando estos conserven la proporcionalidad de la imagen.\nEspacio de pantalla #  El espacio de la pantalla es una proyección de la cámara a un espacio en 2D. Este se utiliza para proyectar lo del espacio de la cámara a una representación en monitores como se conoce hoy en día en los computadores.\nTubería de renderización #  Este es un proceso que decribe los pasos de la renderización de un objeto a su forma 2D o, mejor dicho, del espacio del objeto al espacio de la pantalla.\nSuperliminal #  Superliminal es un videojuego desde la perspectiva de primera persona. La trama del juego consiste en un jugador que se encuentra atrapado en un lugar surreal llamado el espacio de sueños y este debe hallar maneras de escapar de ese lugar. Sin embargo, una características del espacio de sueños mencionados es que el jugador puede cambiar el tamaño de los objetos utilizando la perspectiva forzada.\nPerspectiva forzada #  La perspectiva forzada es un fenómeno en el que el observador es engañado acerca del tamaño de un objeto, es decir, este puede parecer más grande o más pequeño de lo que en realidad es. Esto ocurre ya que la representación de la escena en el ojo humano, en este caso la cámara, percibe el objeto de una manera que parece distinta a la realidad.\n  \\[ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi),e^{2 \\pi i \\xi x},d\\xi \\]  En el caso específico del juego, el jugador tiene el control de la perspectiva forzada, en cuanto este puede en el mundo aumentar y disminuir el tamaño de los objetos sin que, bajo la perspectiva de la cámara se cambie el tamaño. Esto se logra porque ante el espacio de la pantalla que es generado ante el proceso de renderización, la scena creada no cambia a pesar de que en el mundo el objeto sí este cambiando.\n"}]