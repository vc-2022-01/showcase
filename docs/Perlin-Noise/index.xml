<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computación Visual</title><link>https://visualcomputing.github.io/showcase/docs/Perlin-Noise/</link><description>Recent content on Computación Visual</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://visualcomputing.github.io/showcase/docs/Perlin-Noise/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://visualcomputing.github.io/showcase/docs/Perlin-Noise/Particule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/Perlin-Noise/Particule/</guid><description>Movimiento de partículas a través de un campo de perlin noise # En el siguiente frame se puede ver el movimiento con rastro de partículas a través de un campo de perlin noise
" " " si jugamos con la rejilla y la dirección de los vectores, se pueden generar texturas o efectos visuales más complejos</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/Perlin-Noise/Terrain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/Perlin-Noise/Terrain/</guid><description>Terreno procedural # {{&amp;lt; let terrain = []; function setup() { createCanvas(500, 500, WEBGL); cols = 0;rows = 0; elevacion = 100; scl = 25; vel = 0.05; cambio = scl; crecimiento = 0.07; w = 800; h = 800; cols = w/scl; rows = h/scl; avance = 0; } function stripOfTerrain(){ yoff = avance; xoff = 0; for(x = 0; x &amp;lt; (cols);x++){ terrain[x] = []; } for(y = 0; y &amp;lt; (rows); y++){ xoff = 0; for(x = 0; x &amp;lt; (cols);x++){ terrain[x][y] = map(noise(xoff,yoff),0,1,-elevacion,elevacion); xoff += crecimiento; } yoff += crecimiento; } } function draw() { stripOfTerrain(); cols = w/scl; rows = h/scl; avance -= vel; background(&amp;#39;blue&amp;#39;); stroke(255); rotateX(PI/3); translate(-375,-525); for(y = 0; y &amp;lt; rows; y++){ beginShape(TRIANGLE_STRIP); for(x = 0; x &amp;lt; cols;x++){ fill(10,200,200-terrain[x][y]*10) vertex(x*scl,y*scl,terrain[x][y]); fill(10,255,100-terrain[x][y+1]*10) vertex(x*scl,(y+1)*scl,terrain[x][y+1]); } endShape(); } } &amp;gt;}} All parameters are optional but sketch.</description></item></channel></rss>